<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="ErrorLengthGoesPastArrayLimits" xml:space="preserve">
    <value>Lungimea trebuie sp fie suficient de mică încât să nu resulte într-o operație în afara limitelor șirului.</value>
  </data>
  <data name="ErrorLengthMustBeAPositiveInteger" xml:space="preserve">
    <value>Lungimea trebuie să fie un întreg pozitiv.</value>
  </data>
  <data name="ErrorNotImplementedByDesign" xml:space="preserve">
    <value>Acest membru este în mod intenționat neimplementat.</value>
  </data>
  <data name="ErrorSourceIndexMustPointToALocationWithinTheArray" xml:space="preserve">
    <value>Indicele sursă trebuie să indice o locație din interiorul șirului.</value>
  </data>
  <data name="ErrorArgumentInvalidType" xml:space="preserve">
    <value>Argumentul furnizat incapsulat sau polimorfic este de un tip greșit.</value>
  </data>
  <data name="ErrorStopRetrying" xml:space="preserve">
    <value>Operațiunea care a făcut apel la această metodă ar trebui să se oprească din nou, ca o eroare critică, o schimbare de stat sau condiții de mediu nerecuperabile garantează eșec la reluările ulterioare.</value>
  </data>
  <data name="MoveNextNotInvoked" xml:space="preserve">
    <value>Mai întâi trebuie să invocați MoveNext înainte să puteți apela Current.</value>
  </data>
  <data name="DictionaryItemAlreadyExists" xml:space="preserve">
    <value>Un element cu aceeaşi cheie există deja în acest dicţionar.</value>
  </data>
  <data name="ItemAlreadyCapturedIntoUndoContextException" xml:space="preserve">
    <value>Operațiunea nu a putut fi executată deoarece elementul curent este prins într-un context de reversie.</value>
  </data>
  <data name="ItemIsInEditModeExceptionDefaultMessage" xml:space="preserve">
    <value>Operațiunea nu a putut fi executată deoarece elementul este în modul de editare.</value>
  </data>
  <data name="ItemNotCapturedIntoUndoContextException" xml:space="preserve">
    <value>Operațiunea nu a putut fi executată deoarece elementul curent nu este parte al unui context de reversie.</value>
  </data>
  <data name="ItemNotInEditModeExceptionDefaultMessage" xml:space="preserve">
    <value>Operațiunea nu a putut fi executată deoarece elementul nu este în modul de editare.</value>
  </data>
  <data name="OperationItemTypeError" xml:space="preserve">
    <value>Tipul de argument nu este un tip compatibil cu lista.</value>
  </data>
  <data name="ErrorArgumentNotPositiveInteger" xml:space="preserve">
    <value>Argumentul nu este un întreg pozitiv.</value>
  </data>
  <data name="SingleOrDefaultMultipleElements" xml:space="preserve">
    <value>Secvența de intrare conține mai multe elemente.</value>
  </data>
  <data name="AnInvalidSetOfArgumentsWasSpecifiedArgumentNames" xml:space="preserve">
    <value>S-a specificat un set nevalid de argumente. Nume argumente: {0}</value>
  </data>
  <data name="TheProvidedArgumentsDoNotFormAValidRangeOfValuesArguments" xml:space="preserve">
    <value>Argumentele furnizate nu formează un interval valid de valori. Argumente: {0}</value>
  </data>
  <data name="ErrorArgumentNotPositive" xml:space="preserve">
    <value>Argumentul nu este un număr pozitiv.</value>
  </data>
  <data name="ErrorArgumentNullOrEmptyString" xml:space="preserve">
    <value>Argumentul șir este nul (Nimic în Visual Basic) sau gol.</value>
  </data>
  <data name="ErrorArgumentNullOrWhiteSpaceString" xml:space="preserve">
    <value>Argumentul șir este nul (Nimic în Visual Basic), gol sau doar spațiu alb.</value>
  </data>
  <data name="ErrorArgumentNullOrEmptyBinary" xml:space="preserve">
    <value>Argumentul este null (Nimic în Visual Basic) sau o matrice de octeți goală.</value>
  </data>
  <data name="ErrorArgumentNullOrEmptyCollection" xml:space="preserve">
    <value>Argumentul colecției este nul (Nimic în Visual Basic) sau gol.</value>
  </data>
  <data name="AContractConditionIsNotBeingMet" xml:space="preserve">
    <value>O condiție contractuală nu este îndeplinită.</value>
  </data>
  <data name="ErrorArgumentNotValidIndex" xml:space="preserve">
    <value>Argumentul nu poate fi considerat un index valid.</value>
  </data>
  <data name="ErrorArgumentNotValidLength" xml:space="preserve">
    <value>Argumentul nu poate fi considerat o lungime validă, deoarece trebuie să fie un întreg pozitiv mai mic decât lungimea colecției pentru care este utilizat.</value>
  </data>
  <data name="ErrorArgumentNullOrEmptyArray" xml:space="preserve">
    <value>Argumentul matrice este null (Nimic în Visual Basic) sau gol sau nu are lungimea necesară.</value>
  </data>
  <data name="ErrorArgumentDoesNotMatch" xml:space="preserve">
    <value>Argumentul nu se potrivește cu modelul așteptat sau nu s-a potrivit implicit cu nicio intrare acceptată.</value>
  </data>
  <data name="ErrorArgumentInvalidPath" xml:space="preserve">
    <value>Argumentul furnizat nu poate fi utilizat ca o cale validă.</value>
  </data>
  <data name="ErrorKeyFoundInDictionary" xml:space="preserve">
    <value>Cheia dată era deja prezentă în dicționar.</value>
  </data>
  <data name="ErrorQueueIsEmpty" xml:space="preserve">
    <value>Coada este în prezent goală.</value>
  </data>
  <data name="ErrorStackIsEmpty" xml:space="preserve">
    <value>Stiva este în prezent goală.</value>
  </data>
  <data name="LimitArgumentNegativeExceptionDefaultTextNoArgument" xml:space="preserve">
    <value>Argumentul limită trebuie să fie un întreg non-negativ.</value>
  </data>
  <data name="LimitArgumentNegativeExceptionDefaultTextWithArgument" xml:space="preserve">
    <value>Argumentul limită trebuie să fie un întreg non-negativ. Nume argument: {0}</value>
  </data>
  <data name="ErrorPersistedQueuesCannotBeCopied" xml:space="preserve">
    <value>Încercarea de a copia întregul conținut al unei cozi persistente nu este o operațiune acceptată.</value>
  </data>
  <data name="ErrorPersistedQueuesCannotBeEnumerated" xml:space="preserve">
    <value>Încercarea de a enumera o coadă persistentă nu este o operațiune acceptată.</value>
  </data>
  <data name="ErrorTheQueueIsCurrentlyInDisasterMode" xml:space="preserve">
    <value>Coada este în prezent în modul dezastru, operațiunile de enumerare sunt dezactivate prin proiectare.</value>
  </data>
  <data name="ErrorArgumentInRange" xml:space="preserve">
    <value>Argumentul este în intervalul nedorit.</value>
  </data>
  <data name="ErrorArgumentNotGreaterThan" xml:space="preserve">
    <value>Argumentul nu este mai mare decât o valoare dorită.</value>
  </data>
  <data name="ErrorArgumentNotGreaterThanOrEqualTo" xml:space="preserve">
    <value>Argumentul nu este mai mic sau egal cu o valoare dorită.</value>
  </data>
  <data name="ErrorArgumentNotInRange" xml:space="preserve">
    <value>Argumentul nu este în intervalul dorit.</value>
  </data>
  <data name="ErrorArgumentNotLessThan" xml:space="preserve">
    <value>Argumentul nu este mai mic decât o valoare dorită.</value>
  </data>
  <data name="ErrorArgumentNotLessThanOrEqualTo" xml:space="preserve">
    <value>Argumentul nu este mai mic sau egal cu o valoare dorită.</value>
  </data>
  <data name="ErrorArgumentNotNegative" xml:space="preserve">
    <value>Argumentul nu este un număr negativ.</value>
  </data>
  <data name="ErrorArgumentNotNegativeInteger" xml:space="preserve">
    <value>Argumentul nu este un întreg negativ.</value>
  </data>
  <data name="NoHistoryLevelsException" xml:space="preserve">
    <value>Nu s-a putut inițializa nicio anulare/refacere a stivelor, deoarece nu sunt definite niveluri de istoric.</value>
  </data>
  <data name="TheCollectionIsCapturedIntoAContextItCannotStartAnExplicitTransaction" xml:space="preserve">
    <value>Colecția este capturată într-un context, nu poate începe o tranzacție explicită.</value>
  </data>
  <data name="TheGivenCollectionToRemoveIsNotContainedInTheInitialCollection" xml:space="preserve">
    <value>Colecția dată de eliminat nu este conținută în colecția inițială.</value>
  </data>
  <data name="ThereAlreadyIsAnOpenUndoTransaction" xml:space="preserve">
    <value>Există deja o tranzacție deschisă de anulare.</value>
  </data>
  <data name="UndoAndRedoOperationsAreNotSupportedWhileAnExplicitTransactionBlockIsOpen" xml:space="preserve">
    <value>Operațiunile de anulare și refacere nu sunt acceptate în timp ce este deschis un bloc de tranzacții explicit.</value>
  </data>
  <data name="AttemptingToAccessAnUndoRedoStackWhileUndoIsDisabledIsNotAllowed" xml:space="preserve">
    <value>Încercarea de a accesa o stivă de anulare/refacere în timp ce anularea este dezactivată nu este permisă.</value>
  </data>
</root>