<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="..\..\..\opt\tt\NumericTypes.tt" #><#@ include file="..\..\..\opt\tt\TypeNamesFixture.tt" #>
<#@ output extension=".cs" #>
// <copyright file="Requires.NumericTypesValidation.cs" company="Adrian Mos">
// Copyright (c) Adrian Mos with all rights reserved. Part of the IX Framework.
// </copyright>

using System.Diagnostics;
using System.Runtime.CompilerServices;
using JetBrains.Annotations;

namespace IX.StandardExtensions.Contracts
{
    /// <summary>
    ///     Methods for approximating the works of contract-oriented programming.
    /// </summary>
    public static partial class Requires
    {<#
/* STAGE DESCRIPTION:
 * 1. RequiresPositive
 * 2. RequiresNonNegative
 * 3. RequiresPositive with ref
 * 4. RequiresNonNegative with ref
 */
List<string> code = new List<string>();
int stage = 1;

for (int i = 0; i < types.Length; i++)
{
    var typ = types[i];
    string fullTypeName = GetTypeUsableName(typ);
    bool isTypeUnsigned = IsTypeUnsigned(typ);
    bool isReferencing = (stage >= 3);
    bool isNonNegative = (stage == 2 || stage == 4);

    if (!(isNonNegative && isTypeUnsigned))
    {
#>

        /// <summary>
        ///     Called when a <#= isReferencing ? "field initialization" : "contract" #> requires that a numeric argument of type <see cref="<#= fullTypeName #>" /> is
<#
        if (isNonNegative)
        {
#>
        ///     non-negative (greater than or equal to zero).
<#
        }
        else
        {
#>
        ///     positive (greater than zero).
<#
        }
#>
        /// </summary>
<#
        if (isReferencing)
        {
#>
        /// <param name="field">
        ///     The field that the argument is initializing.
        /// </param>
<#
        }
#>
        /// <param name="argument">
        ///     The numeric argument.
        /// </param>
        /// <param name="argumentName">
        ///     The argument name.
        /// </param>
        /// <exception cref="ArgumentNotPositiveIntegerException">
<#
        if (isTypeUnsigned)
        {
#>
        ///     The argument is equal to 0.
<#
        }
        else if (isNonNegative)
        {
#>
        ///     The argument is less than 0.
<#
        }
        else
        {
#>
        ///     The argument is less than or equal to 0.
<#
        }
#>
        /// </exception>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        [System.Diagnostics.CodeAnalysis.SuppressMessage(
            "Performance",
            "EPS02:Non-readonly struct used as in-parameter",
            Justification = "<#= fullTypeName #> is a primitive type that the compiler can handle.")]
        public static void <#= isNonNegative ? "NonNegative" : "Positive" #>(
<#
        if (isReferencing)
        {
#>
            ref <#= fullTypeName #> field,
<#
        }
#>
            in <#= fullTypeName #> argument,
            [NotNull] string argumentName)
        {
            if (argument <#= isTypeUnsigned ? "==" : (isNonNegative ? "<" : "<=") #> 0)
            {
                throw new ArgumentNotPositiveIntegerException(argumentName);
            }
<#
        if (isReferencing)
        {
#>

            field = argument;
<#
        }
#>
        }
<#
    }

    stage++;
    if (stage == 5)
    {
        stage = 1;
    }
    else
    {
        i--;
    }
}
#>
    }
}